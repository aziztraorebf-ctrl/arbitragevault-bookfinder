# Phase 6.2 - Keyword-Based Discovery Implementation Plan

**Date**: 15 Decembre 2025
**Status**: EN ATTENTE VALIDATION
**Skill**: superpowers:writing-plans

---

## Executive Summary

### Problem Statement
Le bouton "Surprise Me!" retourne 0 niches car:
1. `/bestsellers` API retourne les produits les plus populaires = les plus competitifs
2. Ces produits ont Amazon comme vendeur + 15-30 FBA sellers
3. Nos filtres (`exclude_amazon_seller`, `max_fba_sellers`) les eliminent correctement
4. Resultat: 0 produits passent les filtres

### Root Cause
**Mauvaise source de donnees**: `/bestsellers` retourne des produits over-competitifs par design.

### Solution
Utiliser **Keepa Product Finder API** (`/product_finder`) qui permet de filtrer **a la source**:
- `offerCountFBA_lte`: Max FBA sellers (pre-filtre cote Keepa)
- `current_AMAZON_lte=-1`: Exclure Amazon comme vendeur
- `salesRankRange`: BSR min/max
- `currentPrice_gte/lte`: Prix
- `rootCategory`: Categorie
- `title`: Mots-cles de recherche

### Expected Outcome
- "Surprise Me!" retourne 1-3 niches avec produits **actionables**
- Chaque niche contient des produits avec <5 FBA sellers, sans Amazon
- Resultats alignes avec strategie "Immediate Opportunities"

---

## Architecture

### Current Flow (Broken)
```
Frontend "Surprise Me!"
    -> GET /api/v1/niches/discover
    -> discover_curated_niches()
    -> discover_with_scoring()
    -> _discover_via_bestsellers()  <-- PROBLEME ICI
    -> /bestsellers API (retourne top sellers = over-competitifs)
    -> Filtrage post-hoc (elimine tout)
    -> 0 resultats
```

### Target Flow (Fixed)
```
Frontend "Surprise Me!"
    -> GET /api/v1/niches/discover
    -> discover_curated_niches()
    -> discover_with_product_finder()  <-- NOUVEAU
    -> /product_finder API (pre-filtre FBA sellers + Amazon)
    -> Resultats deja filtres
    -> 5-20 produits actionables par niche
```

### Tech Stack
- **Backend**: FastAPI + httpx (deja en place)
- **API**: Keepa Product Finder endpoint
- **Database**: PostgreSQL (cache inchange)
- **Frontend**: React hooks (modification mineure)

---

## Implementation Tasks

### Task 1: Add Product Finder Method to KeepaService
**Fichier**: `backend/app/services/keepa_service.py`
**TDD**: Test FIRST, implementation SECOND

**Test file**: `backend/tests/unit/test_keepa_product_finder_api.py`

```python
"""
Unit tests for Keepa Product Finder API integration.
TDD: Write tests first, then implementation.
"""
import pytest
from unittest.mock import AsyncMock, patch, MagicMock
from app.services.keepa_service import KeepaService

class TestProductFinderAPI:
    """Test Product Finder API method."""

    @pytest.fixture
    def keepa_service(self):
        """Create KeepaService with mocked httpx client."""
        service = KeepaService()
        service.client = AsyncMock()
        return service

    @pytest.mark.asyncio
    async def test_product_finder_builds_correct_params(self, keepa_service):
        """Verify Product Finder API params are built correctly."""
        # Mock response
        keepa_service._make_request = AsyncMock(return_value={
            "asinList": ["B001234567", "B002345678"],
            "totalResults": 2
        })

        result = await keepa_service.product_finder(
            domain=1,
            root_category=10777,  # Law
            bsr_min=30000,
            bsr_max=250000,
            price_min=40.0,
            price_max=180.0,
            max_fba_sellers=3,
            exclude_amazon=True,
            title_keywords="law textbook",
            max_results=50
        )

        # Verify _make_request was called with correct endpoint
        keepa_service._make_request.assert_called_once()
        call_args = keepa_service._make_request.call_args

        assert call_args[0][0] == "/product_finder"
        params = call_args[0][1]

        # Verify filter params
        assert params["domain"] == 1
        assert params["rootCategory"] == 10777
        assert "salesRankRange" in params
        assert params["offerCountFBA_lte"] == 3
        assert params["current_AMAZON_lte"] == -1  # Exclude Amazon

    @pytest.mark.asyncio
    async def test_product_finder_handles_empty_results(self, keepa_service):
        """Verify empty results are handled gracefully."""
        keepa_service._make_request = AsyncMock(return_value={
            "asinList": [],
            "totalResults": 0
        })

        result = await keepa_service.product_finder(
            domain=1,
            root_category=10777,
            max_fba_sellers=1  # Very restrictive
        )

        assert result == []

    @pytest.mark.asyncio
    async def test_product_finder_respects_max_results(self, keepa_service):
        """Verify max_results limits returned ASINs."""
        keepa_service._make_request = AsyncMock(return_value={
            "asinList": ["B00" + str(i).zfill(7) for i in range(100)],
            "totalResults": 100
        })

        result = await keepa_service.product_finder(
            domain=1,
            root_category=10777,
            max_results=10
        )

        assert len(result) <= 10

    @pytest.mark.asyncio
    async def test_product_finder_without_amazon_filter(self, keepa_service):
        """Verify exclude_amazon=False does not add AMAZON filter."""
        keepa_service._make_request = AsyncMock(return_value={
            "asinList": ["B001234567"],
            "totalResults": 1
        })

        await keepa_service.product_finder(
            domain=1,
            root_category=10777,
            exclude_amazon=False
        )

        call_args = keepa_service._make_request.call_args
        params = call_args[0][1]
        assert "current_AMAZON_lte" not in params

    @pytest.mark.asyncio
    async def test_product_finder_with_title_keywords(self, keepa_service):
        """Verify title keywords are included in search."""
        keepa_service._make_request = AsyncMock(return_value={
            "asinList": ["B001234567"],
            "totalResults": 1
        })

        await keepa_service.product_finder(
            domain=1,
            root_category=10777,
            title_keywords="constitutional law"
        )

        call_args = keepa_service._make_request.call_args
        params = call_args[0][1]
        assert params["title"] == "constitutional law"
```

**Implementation** (after tests pass):
```python
# Add to KeepaService class in keepa_service.py

async def product_finder(
    self,
    domain: int,
    root_category: Optional[int] = None,
    bsr_min: Optional[int] = None,
    bsr_max: Optional[int] = None,
    price_min: Optional[float] = None,
    price_max: Optional[float] = None,
    max_fba_sellers: Optional[int] = None,
    exclude_amazon: bool = True,
    title_keywords: Optional[str] = None,
    max_results: int = 50
) -> List[str]:
    """
    Use Keepa Product Finder API to discover products with pre-filtering.

    Unlike /bestsellers, this API filters at source - much more efficient
    for finding low-competition opportunities.

    Args:
        domain: Amazon domain (1=US)
        root_category: Root category ID
        bsr_min: Minimum BSR
        bsr_max: Maximum BSR
        price_min: Minimum price (dollars)
        price_max: Maximum price (dollars)
        max_fba_sellers: Maximum FBA seller count
        exclude_amazon: Exclude products where Amazon is selling
        title_keywords: Search keywords in title
        max_results: Maximum results to return

    Returns:
        List of ASINs matching criteria
    """
    params = {
        "domain": domain,
        "perPage": min(max_results, 100)
    }

    if root_category:
        params["rootCategory"] = root_category

    if bsr_min or bsr_max:
        bsr_range = f"{bsr_min or 0}_{bsr_max or 999999999}"
        params["salesRankRange"] = bsr_range

    if price_min or price_max:
        # Keepa uses cents
        price_min_cents = int((price_min or 0) * 100)
        price_max_cents = int((price_max or 99999) * 100)
        params["current_NEW_gte"] = price_min_cents
        params["current_NEW_lte"] = price_max_cents

    if max_fba_sellers is not None:
        params["offerCountFBA_lte"] = max_fba_sellers

    if exclude_amazon:
        # current_AMAZON_lte=-1 means "no Amazon price" = Amazon not selling
        params["current_AMAZON_lte"] = -1

    if title_keywords:
        params["title"] = title_keywords

    try:
        response = await self._make_request("/product_finder", params)

        if not response:
            return []

        asins = response.get("asinList", [])
        return asins[:max_results]

    except Exception as e:
        logger.error(f"Product Finder API error: {e}")
        return []
```

**Estimation**: 45 min
**Verification**: `pytest backend/tests/unit/test_keepa_product_finder_api.py -v`

---

### Task 2: Add Keywords to Niche Templates
**Fichier**: `backend/app/services/niche_templates.py`
**TDD**: Test template validation

**Test file**: `backend/tests/unit/test_niche_templates_keywords.py`

```python
"""
Test niche templates with keywords field.
"""
import pytest
from app.services.niche_templates import CURATED_NICHES, get_niche_template_by_id

class TestNicheTemplatesKeywords:
    """Test keywords in niche templates."""

    def test_all_templates_have_keywords(self):
        """Every template should have search keywords."""
        for template in CURATED_NICHES:
            assert "keywords" in template, f"Template {template['id']} missing keywords"
            assert isinstance(template["keywords"], list), f"Template {template['id']} keywords should be list"
            assert len(template["keywords"]) >= 1, f"Template {template['id']} needs at least 1 keyword"

    def test_keywords_are_strings(self):
        """Keywords should be non-empty strings."""
        for template in CURATED_NICHES:
            for kw in template["keywords"]:
                assert isinstance(kw, str), f"Keyword in {template['id']} should be string"
                assert len(kw.strip()) > 0, f"Empty keyword in {template['id']}"

    def test_textbook_templates_have_specific_keywords(self):
        """Textbook templates should have domain-specific keywords."""
        law_template = get_niche_template_by_id("textbook-law")
        assert law_template is not None
        keywords_lower = [k.lower() for k in law_template["keywords"]]
        assert any("law" in k for k in keywords_lower)

    def test_smart_velocity_templates_have_keywords(self):
        """Smart velocity templates should have relevant keywords."""
        python_template = get_niche_template_by_id("tech-books-python")
        assert python_template is not None
        keywords_lower = [k.lower() for k in python_template["keywords"]]
        assert any("python" in k for k in keywords_lower)
```

**Implementation** (add keywords to each template):
```python
# Update CURATED_NICHES in niche_templates.py
# Add "keywords" field to each template

CURATED_NICHES = [
    {
        "id": "tech-books-python",
        "name": "[TECH] Python Books Beginners $20-50",
        # ... existing fields ...
        "keywords": ["python programming", "python beginner", "learn python"]
    },
    {
        "id": "textbook-law",
        "name": "[TEXTBOOK] Law & Legal Studies",
        # ... existing fields ...
        "keywords": ["law textbook", "legal studies", "constitutional law", "bar exam"]
    },
    # ... update all 15 templates ...
]
```

**Estimation**: 30 min
**Verification**: `pytest backend/tests/unit/test_niche_templates_keywords.py -v`

---

### Task 3: Create discover_via_product_finder Method
**Fichier**: `backend/app/services/keepa_product_finder.py`
**TDD**: Test new discovery method

**Test file**: `backend/tests/unit/test_discover_via_product_finder.py`

```python
"""
Test discover_via_product_finder method.
"""
import pytest
from unittest.mock import AsyncMock, MagicMock
from decimal import Decimal
from app.services.keepa_product_finder import KeepaProductFinderService

class TestDiscoverViaProductFinder:
    """Test Product Finder discovery method."""

    @pytest.fixture
    def mock_keepa_service(self):
        """Create mock KeepaService."""
        mock = MagicMock()
        mock.product_finder = AsyncMock(return_value=["B001234567", "B002345678"])
        mock._make_request = AsyncMock(return_value={
            "products": [
                {
                    "asin": "B001234567",
                    "title": "Constitutional Law Textbook",
                    "stats": {"current": [0, 5999, 0, 45000, 0, 0, 0, 0, 0, 0, 0, 2]}
                },
                {
                    "asin": "B002345678",
                    "title": "Criminal Law Guide",
                    "stats": {"current": [0, 7500, 0, 65000, 0, 0, 0, 0, 0, 0, 0, 3]}
                }
            ]
        })
        mock._ensure_sufficient_balance = AsyncMock()
        return mock

    @pytest.fixture
    def mock_config_service(self):
        """Create mock ConfigService."""
        mock = MagicMock()
        mock.get_effective_config = AsyncMock()
        return mock

    @pytest.mark.asyncio
    async def test_discover_via_product_finder_calls_api(
        self, mock_keepa_service, mock_config_service
    ):
        """Verify Product Finder API is called with correct params."""
        finder = KeepaProductFinderService(
            keepa_service=mock_keepa_service,
            config_service=mock_config_service,
            db=None
        )

        await finder._discover_via_product_finder(
            domain=1,
            category=10777,
            bsr_min=30000,
            bsr_max=250000,
            price_min=40.0,
            price_max=180.0,
            max_results=20,
            max_fba_sellers=3,
            keywords=["law textbook"]
        )

        mock_keepa_service.product_finder.assert_called_once()
        call_kwargs = mock_keepa_service.product_finder.call_args[1]
        assert call_kwargs["root_category"] == 10777
        assert call_kwargs["max_fba_sellers"] == 3
        assert call_kwargs["exclude_amazon"] == True
        assert "law textbook" in call_kwargs["title_keywords"]

    @pytest.mark.asyncio
    async def test_discover_via_product_finder_returns_asins(
        self, mock_keepa_service, mock_config_service
    ):
        """Verify method returns filtered ASINs."""
        finder = KeepaProductFinderService(
            keepa_service=mock_keepa_service,
            config_service=mock_config_service,
            db=None
        )

        result = await finder._discover_via_product_finder(
            domain=1,
            category=10777,
            max_results=10
        )

        assert len(result) == 2
        assert "B001234567" in result
        assert "B002345678" in result

    @pytest.mark.asyncio
    async def test_discover_via_product_finder_with_multiple_keywords(
        self, mock_keepa_service, mock_config_service
    ):
        """Test with multiple keywords (uses first one)."""
        finder = KeepaProductFinderService(
            keepa_service=mock_keepa_service,
            config_service=mock_config_service,
            db=None
        )

        await finder._discover_via_product_finder(
            domain=1,
            category=10777,
            keywords=["law textbook", "legal studies", "bar exam"]
        )

        # Should use first keyword
        call_kwargs = mock_keepa_service.product_finder.call_args[1]
        assert call_kwargs["title_keywords"] == "law textbook"
```

**Implementation**:
```python
# Add to KeepaProductFinderService class

async def _discover_via_product_finder(
    self,
    domain: int,
    category: int,
    bsr_min: Optional[int] = None,
    bsr_max: Optional[int] = None,
    price_min: Optional[float] = None,
    price_max: Optional[float] = None,
    max_results: int = 50,
    max_fba_sellers: Optional[int] = None,
    keywords: Optional[List[str]] = None
) -> List[str]:
    """
    Discover products using Keepa Product Finder API.

    Pre-filters at source for FBA sellers and Amazon presence.
    Much more efficient than bestsellers + post-filtering.

    Args:
        keywords: List of search keywords (uses first one)

    Returns:
        List of ASINs matching criteria
    """
    try:
        # Use first keyword if provided
        title_keywords = keywords[0] if keywords else None

        asins = await self.keepa_service.product_finder(
            domain=domain,
            root_category=category,
            bsr_min=bsr_min,
            bsr_max=bsr_max,
            price_min=price_min,
            price_max=price_max,
            max_fba_sellers=max_fba_sellers,
            exclude_amazon=True,  # Always exclude Amazon for arbitrage
            title_keywords=title_keywords,
            max_results=max_results
        )

        logger.info(
            f"Product Finder discovery: {len(asins)} ASINs "
            f"(category={category}, keywords={title_keywords})"
        )

        return asins

    except Exception as e:
        logger.error(f"Product Finder discovery error: {e}")
        return []
```

**Estimation**: 45 min
**Verification**: `pytest backend/tests/unit/test_discover_via_product_finder.py -v`

---

### Task 4: Update discover_products to Use Product Finder
**Fichier**: `backend/app/services/keepa_product_finder.py`
**Modification**: Change strategy from bestsellers to product_finder

**Test file**: `backend/tests/integration/test_discovery_strategy_switch.py`

```python
"""
Integration test for discovery strategy switch.
"""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

class TestDiscoveryStrategySwitch:
    """Test that discover_products uses Product Finder when keywords provided."""

    @pytest.mark.asyncio
    async def test_discover_products_uses_product_finder_when_keywords(self):
        """When keywords provided, should use Product Finder API."""
        with patch(
            "app.services.keepa_product_finder.KeepaProductFinderService._discover_via_product_finder"
        ) as mock_pf:
            mock_pf.return_value = ["B001234567"]

            # Create service with mocks
            from app.services.keepa_product_finder import KeepaProductFinderService

            mock_keepa = MagicMock()
            mock_config = MagicMock()

            finder = KeepaProductFinderService(mock_keepa, mock_config, None)

            result = await finder.discover_products(
                domain=1,
                category=10777,
                bsr_min=30000,
                bsr_max=250000,
                max_results=20,
                keywords=["law textbook"]  # Keywords provided
            )

            mock_pf.assert_called_once()
            assert "B001234567" in result

    @pytest.mark.asyncio
    async def test_discover_products_falls_back_to_bestsellers(self):
        """Without keywords, should fall back to bestsellers."""
        with patch(
            "app.services.keepa_product_finder.KeepaProductFinderService._discover_via_bestsellers"
        ) as mock_bs:
            mock_bs.return_value = ["B009999999"]

            from app.services.keepa_product_finder import KeepaProductFinderService

            mock_keepa = MagicMock()
            mock_keepa._ensure_sufficient_balance = AsyncMock()
            mock_config = MagicMock()

            finder = KeepaProductFinderService(mock_keepa, mock_config, None)

            result = await finder.discover_products(
                domain=1,
                category=10777,
                max_results=20
                # No keywords - should use bestsellers
            )

            mock_bs.assert_called_once()
```

**Implementation** (modify discover_products):
```python
# Update discover_products method signature and logic

async def discover_products(
    self,
    domain: int,
    category: Optional[int] = None,
    bsr_min: Optional[int] = None,
    bsr_max: Optional[int] = None,
    price_min: Optional[float] = None,
    price_max: Optional[float] = None,
    max_results: int = 100,
    max_fba_sellers: Optional[int] = None,
    keywords: Optional[List[str]] = None  # NEW PARAMETER
) -> List[str]:
    """
    Discover products - uses Product Finder when keywords available.

    Strategy:
        1. If keywords provided -> Product Finder API (pre-filtered)
        2. Else if category -> Bestsellers API + post-filtering
        3. Else -> Deals API
    """
    discovered_asins: List[str] = []

    try:
        # Strategy 1: Product Finder (preferred for arbitrage)
        if keywords and category:
            logger.info(f"Discovering via Product Finder - Keywords: {keywords[0]}")
            discovered_asins = await self._discover_via_product_finder(
                domain=domain,
                category=category,
                bsr_min=bsr_min,
                bsr_max=bsr_max,
                price_min=price_min,
                price_max=price_max,
                max_results=max_results,
                max_fba_sellers=max_fba_sellers,
                keywords=keywords
            )
        elif category:
            # Strategy 2: Bestsellers (fallback)
            logger.info(f"Discovering via bestsellers - Category {category}")
            discovered_asins = await self._discover_via_bestsellers(
                domain=domain,
                category=category,
                bsr_min=bsr_min,
                bsr_max=bsr_max,
                price_min=price_min,
                price_max=price_max,
                max_results=max_results,
                max_fba_sellers=max_fba_sellers
            )
        else:
            # Strategy 3: Deals
            logger.info("Discovering via current deals")
            discovered_asins = await self._discover_via_deals(
                domain=domain,
                price_min=price_min,
                price_max=price_max,
                max_results=max_results
            )

        logger.info(f"Discovered {len(discovered_asins)} ASINs")
        return discovered_asins[:max_results]

    except Exception as e:
        logger.error(f"Product discovery error: {e}")
        raise
```

**Estimation**: 30 min
**Verification**: `pytest backend/tests/integration/test_discovery_strategy_switch.py -v`

---

### Task 5: Update discover_curated_niches to Pass Keywords
**Fichier**: `backend/app/services/niche_templates.py`
**Modification**: Pass keywords from template to discover_with_scoring

**Test file**: `backend/tests/unit/test_discover_curated_niches_keywords.py`

```python
"""
Test discover_curated_niches passes keywords to Product Finder.
"""
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

class TestDiscoverCuratedNichesKeywords:
    """Test keyword passing in curated niche discovery."""

    @pytest.mark.asyncio
    async def test_discover_curated_niches_passes_keywords(self):
        """Verify keywords from template are passed to discover_with_scoring."""
        with patch(
            "app.services.niche_templates.KeepaProductFinderService"
        ) as MockFinder:
            mock_instance = MagicMock()
            mock_instance.discover_with_scoring = AsyncMock(return_value=[
                {"asin": "B001234567", "roi_percent": 45, "velocity_score": 60}
            ])
            MockFinder.return_value = mock_instance

            from app.services.niche_templates import _discover_curated_niches_impl

            mock_db = MagicMock()

            result = await _discover_curated_niches_impl(
                db=mock_db,
                product_finder=mock_instance,
                count=1,
                shuffle=False
            )

            # Verify discover_with_scoring was called with keywords
            call_kwargs = mock_instance.discover_with_scoring.call_args[1]
            assert "keywords" in call_kwargs
            assert isinstance(call_kwargs["keywords"], list)
```

**Implementation**:
```python
# Update _discover_curated_niches_impl in niche_templates.py

async def _discover_curated_niches_impl(
    db: Union[Session, AsyncSession],
    product_finder: KeepaProductFinderService,
    count: int,
    shuffle: bool
) -> List[Dict]:
    """Implementation with keyword support."""
    # ... existing code ...

    for tmpl in templates:
        try:
            # Extract keywords from template
            keywords = tmpl.get("keywords", [])

            products = await product_finder.discover_with_scoring(
                domain=1,
                category=tmpl["categories"][0],
                bsr_min=tmpl["bsr_range"][0],
                bsr_max=tmpl["bsr_range"][1],
                price_min=tmpl["price_range"][0],
                price_max=tmpl["price_range"][1],
                max_results=10,
                max_fba_sellers=tmpl.get("max_fba_sellers"),
                keywords=keywords  # NEW: Pass keywords
            )

            # ... rest of filtering and validation ...
```

**Estimation**: 20 min
**Verification**: `pytest backend/tests/unit/test_discover_curated_niches_keywords.py -v`

---

### Task 6: Update discover_with_scoring to Accept Keywords
**Fichier**: `backend/app/services/keepa_product_finder.py`
**Modification**: Add keywords parameter to discover_with_scoring

**Test**: Part of existing test suite update

```python
# Update discover_with_scoring signature

async def discover_with_scoring(
    self,
    domain: int,
    category: Optional[int] = None,
    bsr_min: Optional[int] = None,
    bsr_max: Optional[int] = None,
    price_min: Optional[float] = None,
    price_max: Optional[float] = None,
    min_roi: Optional[float] = None,
    min_velocity: Optional[float] = None,
    max_results: int = 50,
    force_refresh: bool = False,
    max_fba_sellers: Optional[int] = None,
    exclude_amazon_seller: bool = True,
    keywords: Optional[List[str]] = None  # NEW PARAMETER
) -> List[Dict[str, Any]]:
    """
    Discover products with full scoring.

    Now supports keyword-based discovery via Product Finder API.
    """
    # ... existing cache logic ...

    if not asins:
        asins = await self.discover_products(
            domain=domain,
            category=category,
            bsr_min=bsr_min,
            bsr_max=bsr_max,
            price_min=price_min,
            price_max=price_max,
            max_results=max_results * 2,
            max_fba_sellers=max_fba_sellers,
            keywords=keywords  # Pass keywords to discovery
        )

    # ... rest of scoring logic ...
```

**Estimation**: 15 min
**Verification**: Existing tests + integration test

---

### Task 7: E2E Test - Full Flow Validation
**Fichier**: `backend/tests/e2e/tests/phase6.2-keyword-discovery.spec.js`

```javascript
/**
 * E2E Test: Keyword-Based Niche Discovery
 * Validates full flow from API to results
 */
const { test, expect } = require('@playwright/test');

const BACKEND_URL = process.env.BACKEND_URL || 'http://localhost:8000';

test.describe('Phase 6.2 - Keyword Discovery', () => {

  test('GET /niches/discover returns niches with keywords', async ({ request }) => {
    const response = await request.get(`${BACKEND_URL}/api/v1/niches/discover`, {
      params: { count: 1, shuffle: false }
    });

    // Should succeed or return 429 (token limit)
    expect([200, 429]).toContain(response.status());

    if (response.status() === 200) {
      const data = await response.json();

      // Should have metadata with niches
      expect(data.metadata).toBeDefined();
      expect(data.metadata.mode).toBe('auto');

      // If niches returned, validate structure
      if (data.metadata.niches_count > 0) {
        const niche = data.metadata.niches[0];
        expect(niche.id).toBeDefined();
        expect(niche.products_found).toBeGreaterThanOrEqual(1);
        expect(niche.avg_roi).toBeGreaterThan(0);
      }
    }
  });

  test('Niches contain low-competition products', async ({ request }) => {
    const response = await request.get(`${BACKEND_URL}/api/v1/niches/discover`, {
      params: { count: 1, shuffle: false }
    });

    if (response.status() === 200) {
      const data = await response.json();

      if (data.metadata.niches_count > 0) {
        const niche = data.metadata.niches[0];

        // Top products should exist
        expect(niche.top_products).toBeDefined();

        // If products exist, they should have low FBA competition
        // (verified by the fact they passed max_fba_sellers filter)
        if (niche.top_products.length > 0) {
          const product = niche.top_products[0];
          expect(product.asin).toBeDefined();
          expect(product.roi_percent).toBeGreaterThan(0);
        }
      }
    }
  });

});
```

**Estimation**: 20 min
**Verification**: `npx playwright test backend/tests/e2e/tests/phase6.2-keyword-discovery.spec.js`

---

### Task 8: Verification Checkpoint
**Verification commands**:

```bash
# 1. Run all new unit tests
cd backend && pytest tests/unit/test_keepa_product_finder_api.py tests/unit/test_niche_templates_keywords.py tests/unit/test_discover_via_product_finder.py tests/unit/test_discover_curated_niches_keywords.py -v

# 2. Run integration tests
pytest tests/integration/test_discovery_strategy_switch.py -v

# 3. Run E2E tests
npx playwright test tests/e2e/tests/phase6.2-keyword-discovery.spec.js

# 4. Build frontend (should still work)
cd ../frontend && npm run build

# 5. Production validation (after deploy)
curl -s "https://arbitragevault-backend-v2.onrender.com/api/v1/niches/discover?count=1" | jq '.metadata.niches_count'
```

**Estimation**: 30 min

---

## Summary

| Task | Description | Estimation | Dependencies |
|------|-------------|------------|--------------|
| 1 | Add product_finder method to KeepaService | 45 min | None |
| 2 | Add keywords to niche templates | 30 min | None |
| 3 | Create _discover_via_product_finder method | 45 min | Task 1 |
| 4 | Update discover_products strategy | 30 min | Task 3 |
| 5 | Update discover_curated_niches | 20 min | Task 2, 4 |
| 6 | Update discover_with_scoring signature | 15 min | Task 4 |
| 7 | E2E tests | 20 min | Task 5, 6 |
| 8 | Verification checkpoint | 30 min | All |

**Total Estimation**: ~4 heures

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Product Finder API different from docs | HIGH | Test with MCP first, verify response structure |
| Token cost higher than expected | MEDIUM | Monitor with Budget Guard, adjust max_results |
| Keywords too specific = 0 results | MEDIUM | Use broad keywords, fallback to bestsellers |
| Rate limiting on Product Finder | LOW | Use existing rate limit protection in _make_request |

---

## Rollback Plan

If Product Finder integration fails:
1. Revert to bestsellers-only strategy
2. Consider relaxing filter thresholds temporarily
3. Document specific failure mode for future fix

---

## Next Steps After Validation

1. Deploy to Render (staging first if available)
2. Monitor logs for Product Finder API calls
3. Validate "Surprise Me!" returns >0 niches
4. Update compact_current.md with Phase 6.2 completion

---

**Plan Status**: EN ATTENTE VALIDATION UTILISATEUR
**Author**: Claude (superpowers:writing-plans)
**Date**: 15 Decembre 2025
