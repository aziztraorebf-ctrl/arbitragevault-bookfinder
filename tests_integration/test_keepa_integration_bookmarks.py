"""Test d'int√©gration avec les vraies donn√©es Keepa pour la fonctionnalit√© de bookmarking."""

import sys
import os
import asyncio
import json
from datetime import datetime
from typing import Optional

sys.path.append('C:\\Users\\azizt\\Workspace\\arbitragevault_bookfinder\\backend')

# Imports du projet
from app.services.niche_discovery_service import NicheDiscoveryService
from app.services.bookmark_service import BookmarkService
from app.services.keepa_service import KeepaService
from app.schemas.bookmark import NicheCreateSchema
from app.models.bookmark import SavedNiche
from app.models.niche import NicheAnalysisCriteria, NicheAnalysisRequest
from sqlalchemy.orm import Session
from unittest.mock import Mock

# Pour r√©cup√©rer les cl√©s API
try:
    import keyring
    print("‚úÖ Keyring disponible - R√©cup√©ration des cl√©s API Memex")
except ImportError:
    print("‚ùå Keyring non disponible - Installation requise: uv tool install keyring")
    sys.exit(1)


def get_keepa_api_key() -> Optional[str]:
    """R√©cup√®re la cl√© API Keepa des secrets Memex."""
    try:
        # Essayer diff√©rentes variantes du nom de cl√©
        key_variants = ["KEEPA_API_KEY", "keepa_api_key", "Keepa_API_Key", "KEEPA_KEY"]
        
        for variant in key_variants:
            try:
                key = keyring.get_password("memex", variant)
                if key:
                    print(f"‚úÖ Cl√© API Keepa trouv√©e: {variant}")
                    return key
            except Exception as e:
                continue
        
        print("‚ùå Aucune cl√© API Keepa trouv√©e dans les secrets Memex")
        print("   Cl√©s test√©es:", key_variants)
        return None
        
    except Exception as e:
        print(f"‚ùå Erreur r√©cup√©ration cl√© API: {e}")
        return None


async def test_real_niche_discovery_and_bookmarking():
    """Test complet avec vraies donn√©es Keepa."""
    
    print("=== TEST INT√âGRATION KEEPA + BOOKMARKING ===\n")
    
    # 1. R√©cup√©ration cl√© API
    keepa_key = get_keepa_api_key()
    if not keepa_key:
        print("‚ö†Ô∏è Impossible de continuer sans cl√© API Keepa")
        print("   Ajoutez la cl√© via les secrets Memex UI")
        return False
    
    print(f"‚úÖ Cl√© API r√©cup√©r√©e (longueur: {len(keepa_key)} caract√®res)")
    
    # 2. Configuration du service de d√©couverte
    print("\n=== √âTAPE 1: D√âCOUVERTE DE NICHE AVEC VRAIES DONN√âES ===")
    
    # Mock de la base de donn√©es pour les services
    mock_db = Mock(spec=Session)
    
    try:
        # Configuration crit√®res d'analyse r√©alistes
        criteria = NicheAnalysisCriteria(
            bsr_range=(5000, 300000),    # BSR raisonnable pour les livres
            max_sellers=8,               # Concurrence mod√©r√©e
            min_margin_percent=25.0,     # Marge minimum 25%
            min_price_stability=0.6,     # Stabilit√© prix minimum
            sample_size=50               # Taille d'√©chantillon pour test
        )
        
        # Requ√™te d'analyse compl√®te
        analysis_request = NicheAnalysisRequest(
            criteria=criteria,
            target_categories=None,  # Utiliser les cat√©gories par d√©faut
            max_results=5            # Limiter pour le test
        )
        
        print(f"‚úÖ Crit√®res d'analyse configur√©s:")
        print(f"   BSR: {criteria.bsr_range[0]:,} - {criteria.bsr_range[1]:,}")
        print(f"   Marge min: {criteria.min_margin_percent}%")
        print(f"   Vendeurs max: {criteria.max_sellers}")
        print(f"   √âchantillon: {criteria.sample_size} produits")
        
        # Initialiser les services avec la vraie cl√©
        os.environ['KEEPA_API_KEY'] = keepa_key
        keepa_service = KeepaService(api_key=keepa_key)
        discovery_service = NicheDiscoveryService(keepa_service)
        
        # Lancer une vraie analyse
        print(f"\nüîç Lancement analyse avec API Keepa...")
        analysis_response = await discovery_service.discover_niches(analysis_request)
        discovered_niches = analysis_response.discovered_niches
        
        if not discovered_niches:
            print("‚ùå Aucune niche d√©couverte - V√©rifier les crit√®res ou l'API")
            return False
        
        print(f"‚úÖ {len(discovered_niches)} niche(s) d√©couverte(s)")
        
        # Prendre la premi√®re niche pour les tests
        test_niche = discovered_niches[0]
        print(f"\nüìä Niche s√©lectionn√©e pour test: {test_niche.category_name}")
        print(f"   Score: {test_niche.niche_score}/10")
        print(f"   Produits viables: {test_niche.metrics.viable_products}/{test_niche.metrics.total_products}")
        print(f"   Prix moyen: ${test_niche.metrics.avg_price:.2f}")
        print(f"   Marge profit: {test_niche.metrics.profit_margin:.1f}%")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la d√©couverte: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    # 3. Test de sauvegarde avec BookmarkService
    print(f"\n=== √âTAPE 2: SAUVEGARDE VIA BOOKMARK SERVICE ===")
    
    try:
        # Pr√©parer les donn√©es pour la sauvegarde
        # Estimer une plage de prix bas√©e sur le prix moyen de la niche
        avg_price = test_niche.metrics.avg_price
        price_min = max(15.0, avg_price * 0.7)  # 30% en dessous du prix moyen, min 15$
        price_max = min(300.0, avg_price * 1.5)  # 50% au dessus du prix moyen, max 300$
        
        filters_to_save = {
            # Param√®tres compatibles Keepa
            "current_AMAZON_gte": int(price_min * 100),  # En centimes
            "current_AMAZON_lte": int(price_max * 100),  # En centimes
            "current_SALES_gte": criteria.bsr_range[0],
            "current_SALES_lte": criteria.bsr_range[1],
            "categories_include": [test_niche.category_id],
            
            # Param√®tres m√©tier
            "min_margin_percent": criteria.min_margin_percent,
            "max_sellers": criteria.max_sellers,
            "min_price_stability": criteria.min_price_stability,
            
            # M√©tadonn√©es de d√©couverte
            "analysis_date": datetime.now().isoformat(),
            "keepa_api_used": True,
            "total_products_analyzed": test_niche.metrics.total_products
        }
        
        niche_to_bookmark = NicheCreateSchema(
            niche_name=f"{test_niche.category_name} - Test Int√©gration",
            category_id=test_niche.category_id,
            category_name=test_niche.category_name,
            filters=filters_to_save,
            last_score=test_niche.niche_score,
            description=f"Niche d√©couverte via test d'int√©gration le {datetime.now().strftime('%Y-%m-%d %H:%M')} - {test_niche.metrics.viable_products} produits viables identifi√©s avec API Keepa"
        )
        
        # Mock pour BookmarkService (sans vraie DB)
        mock_db.query.return_value.filter.return_value.first.return_value = None  # Pas de doublon
        mock_db.add = Mock()
        mock_db.commit = Mock()
        
        # Mock l'objet qui sera cr√©√©
        def mock_refresh(obj):
            obj.id = 123
            obj.created_at = datetime.now()
        
        mock_db.refresh = Mock(side_effect=mock_refresh)
        
        bookmark_service = BookmarkService(mock_db)
        user_id = "integration_test_user"
        
        saved_niche = bookmark_service.create_niche(user_id, niche_to_bookmark)
        
        print(f"‚úÖ Niche sauvegard√©e avec succ√®s:")
        print(f"   ID: {saved_niche.id}")
        print(f"   Nom: {saved_niche.niche_name}")
        print(f"   Filtres: {len(saved_niche.filters)} param√®tres stock√©s")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la sauvegarde: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    # 4. Test de r√©cup√©ration et relance
    print(f"\n=== √âTAPE 3: R√âCUP√âRATION ET 'RELANCER L'ANALYSE' ===")
    
    try:
        # Mock pour r√©cup√©rer la niche sauvegard√©e
        mock_db.query.return_value.filter.return_value.first.return_value = saved_niche
        
        # R√©cup√©rer les filtres pour relancer l'analyse
        retrieved_filters = bookmark_service.get_niche_filters_for_analysis(user_id, saved_niche.id)
        
        if not retrieved_filters:
            print("‚ùå √âchec r√©cup√©ration des filtres")
            return False
        
        print(f"‚úÖ Filtres r√©cup√©r√©s pour relance:")
        print(f"   current_AMAZON_gte: {retrieved_filters['current_AMAZON_gte']} (${retrieved_filters['current_AMAZON_gte']/100:.2f})")
        print(f"   current_AMAZON_lte: {retrieved_filters['current_AMAZON_lte']} (${retrieved_filters['current_AMAZON_lte']/100:.2f})")
        print(f"   current_SALES_gte: {retrieved_filters['current_SALES_gte']:,}")
        print(f"   current_SALES_lte: {retrieved_filters['current_SALES_lte']:,}")
        print(f"   categories_include: {retrieved_filters['categories_include']}")
        
        # Reconstruire les crit√®res √† partir des filtres sauvegard√©s
        reconstructed_criteria = NicheAnalysisCriteria(
            bsr_range=(retrieved_filters['current_SALES_gte'], retrieved_filters['current_SALES_lte']),
            max_sellers=retrieved_filters['max_sellers'],
            min_margin_percent=retrieved_filters['min_margin_percent'],
            min_price_stability=retrieved_filters['min_price_stability'],
            sample_size=30  # Plus petit √©chantillon pour la relance
        )
        
        # Requ√™te de relance
        relaunch_request = NicheAnalysisRequest(
            criteria=reconstructed_criteria,
            target_categories=retrieved_filters['categories_include'],
            max_results=3
        )
        
        print(f"\nüîÑ Test de relance d'analyse avec param√®tres r√©cup√©r√©s...")
        
        # Relancer une nouvelle analyse
        relaunch_response = await discovery_service.discover_niches(relaunch_request)
        relaunched_niches = relaunch_response.discovered_niches
        
        if not relaunched_niches:
            print("‚ö†Ô∏è Aucun r√©sultat lors de la relance (peut √™tre normal si march√© a chang√©)")
        else:
            relaunch_niche = relaunched_niches[0]
            print(f"‚úÖ Analyse relanc√©e avec succ√®s:")
            print(f"   M√™me cat√©gorie: {relaunch_niche.category_name}")
            print(f"   Nouveau score: {relaunch_niche.niche_score}/10")
            print(f"   Diff√©rence score: {relaunch_niche.niche_score - test_niche.niche_score:+.1f}")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la relance: {e}")
        import traceback
        traceback.print_exc()
        return False
    
    # 5. Validation finale
    print(f"\n=== VALIDATION FINALE ===")
    
    validation_checks = [
        ("API Keepa fonctionne", len(discovered_niches) > 0),
        ("Donn√©es bien structur√©es", test_niche.metrics.avg_price > 0),
        ("Sauvegarde r√©ussie", saved_niche.id is not None),
        ("Filtres pr√©serv√©s", len(retrieved_filters) >= 6),
        ("Relance possible", True),  # Si on arrive ici, c'est ok
        ("Compatibilit√© Keepa", retrieved_filters.get('current_AMAZON_gte') is not None)
    ]
    
    all_passed = all(passed for _, passed in validation_checks)
    
    for check, passed in validation_checks:
        status = "‚úÖ" if passed else "‚ùå"
        print(f"   {status} {check}")
    
    if all_passed:
        print(f"\nüéâ INT√âGRATION KEEPA + BOOKMARKING VALID√âE !")
        print(f"   - Vraies donn√©es Keepa trait√©es correctement")
        print(f"   - Structures compatibles avec l'API officielle")
        print(f"   - Workflow complet fonctionnel")
        print(f"   - Fonctionnalit√© 'Relancer l'analyse' op√©rationnelle")
        return True
    else:
        print(f"\n‚ùå PROBL√àMES D√âTECT√âS - CORRECTIONS N√âCESSAIRES")
        return False


async def main():
    """Point d'entr√©e principal."""
    print("üöÄ D√âMARRAGE TEST INT√âGRATION KEEPA + BOOKMARKING")
    print("=" * 60)
    
    try:
        success = await test_real_niche_discovery_and_bookmarking()
        
        if success:
            print("\n" + "=" * 60)
            print("‚úÖ TOUS LES TESTS D'INT√âGRATION SONT PASS√âS!")
            print("üöÄ LA FONCTIONNALIT√â EST PR√äTE POUR PRODUCTION!")
            print("\nCapacit√©s valid√©es:")
            print("- D√©couverte de niches avec vraies donn√©es Keepa")
            print("- Sauvegarde avec filtres compatibles API")
            print("- R√©cup√©ration et relance d'analyse")
            print("- Int√©gration compl√®te backend")
        else:
            print("\n" + "=" * 60)
            print("‚ùå DES PROBL√àMES ONT √âT√â D√âTECT√âS")
            print("‚ö†Ô∏è CORRECTIONS N√âCESSAIRES AVANT PRODUCTION")
            
    except Exception as e:
        print(f"\nüí• ERREUR CRITIQUE: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    asyncio.run(main())